---
title: An Introduction to the markdown package
author: Yihui Xie
date: "`r Sys.Date()`"
output:
  markdown::html_format:
    options:
      toc: true
---

```{=html}
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{An Introduction to the markdown package}
-->
<style type="text/css">
#TOC {
  float: right;
  border-left: 1px dashed;
  margin-left: 2em;
}
#TOC ul { margin: 0; }
</style>
```
The **markdown** package is built on top of **commonmark**. It renders Markdown
to output formats supported by **commonmark**, and the primary output formats
are HTML and LaTeX.

Historically, it uses a C library named **sundown**, which has been deleted and
replaced by **commonmark** since v1.3 (2022-10-30). The main advantage of the
latter is that it follows a clear and widely used spec, i.e., GFM ([GitHub
Flavored Markdown](https://github.github.com/gfm/)), which can be seen as a
(small) subset of [Pandoc's
Markdown](https://pandoc.org/MANUAL.html#pandocs-markdown). Therefore the
**markdown** package can be viewed as a small subset of the **rmarkdown**
package (the latter is based on Pandoc but the former doesn't depend on external
tools). It aims at simplicity, lightweight, and speed, at the cost of giving up
a lot of features.

## Markdown Syntax

For the full list of supported document elements, please read the GFM spec.
Below is a quick and incomplete summary:

-   Headings start with a number of `#`'s, e.g., `## second-level heading`.

-   Inline elements: `**strong**`, `_emphasis_`, `~~strikethrough~~`,
    `[text](link)`, and `![alt](image/path)`.

-   Inline code is written in a pair of backticks, e.g., `` `code` ``. Code
    blocks can be indented, or fenced by ```` ``` ````.

-   List items start with `-`, `+`, or `*`, e.g., `- item`. A task list item is
    a regular list item with `[ ]` or `[x]` in the beginning, e.g.,
    `- [ ] item`.

-   Block quotes start with `>`.

-   Tables are created with `|` as the column separator (i.e., Pandoc's pipe
    table, which can be generated by `knitr::kable(x, "pipe")`).

In addition to GFM features, the **markdown** package has added support for
these features:

-   Raw LaTeX and HTML blocks as fenced code blocks with language names `=tex`
    (or `=latex`) and `=html`, e.g.,

    ```` markdown
    ```{=tex}
    This only appears in \LaTeX{} output.
    ```
    ````

    Raw LaTeX blocks will only appear in LaTeX output, and will be ignored in
    other output formats. Similarly, raw HTML blocks will only appear in HTML
    output. One exception is raw LaTeX blocks that are LaTeX math environments,
    which also work for HTML output (see the next bullet).

-   Both `$inline$` and `$$display$$` LaTeX math, e.g.,
    $\sin^{2}(\theta)+\cos^{2}(\theta) = 1$

    $$
    \bar{X} = \frac{1}{n} \sum_{i=1}^n X_i
    $$

    LaTeX math environments `equation`, `align`, `eqnarray`, and `gather` are
    also supported, e.g., below is an `eqnarray` environment (equations are
    aligned at the equal signs):

    ```{=latex}
    \begin{eqnarray}
    a^{2}+b^{2} & = & c^{2}\\
    \sin^{2}(\theta)+\cos^{2}(\theta) & = & 1
    \end{eqnarray}
    ```
    These math environments can be written in raw LaTeX blocks, and they work
    for both LaTeX and HTML output.

-   Superscripts via `^text^` and subscripts via `~text~` (same syntax as
    Pandoc's Markdown), e.g., 2^10^ and H~2~O. Currently only alphanumeric
    characters, `*`, `(`, and `)` are allowed in the scripts. For example,
    `a^b c^` will not be recognized as a superscript. Note that GFM supports
    striking out text via `~text~`, but this feature has been disabled and
    replaced by the feature of subscripts in **markdown**. To strike out text,
    you must use a pair of *double* tildes.

-   Footnotes via `[^n]`, where `n` is a footnote number (a unique identifier).
    The footnote content should be defined in a separate block starting with
    `[^n]:`. For example:

    ``` markdown
    Insert a footnote here.[^1]

    [^1]: This is the footnote.
    ```

    The support is limited for LaTeX output,[^1] and there are two caveats if
    the document is intended to be converted to LaTeX:

    -   The footnote content must be a single paragraph.

    -   Only numbers[^2] are supported as identifiers, and other types of
        identifiers are not recognized.

    The two limitations do not apply to HTML output, e.g., you can write
    arbitrary elements in footnotes and not necessarily one paragraph.

-   Attributes on images and section headers. For example,
    `![text](path){.foo #bar width="50%"}` will generate an `<img>` tag with
    attributes in HTML output:

    ``` html
    <img src="path" alt="text" class="foo" id="bar" width="50%" />
    ```

    and `## Header {#baz}` will generate:

    ``` html
    <h2 id="baz">Header</h2>
    ```

    All attributes in `{}` are ignored for LaTeX output except for the `width`
    attribute for images.

-   Fenced `Div`s via `:::`. Note that the opening fence must have at least one
    attribute, such as the class name. For example:

    ``` markdown
    ::: foo
    This is a fenced Div.
    :::

    ::: {.foo}
    The syntax `::: foo` is equivalent to `::: {.foo}`.
    :::

    ::: {.foo #bar style="color: red;"}
    This div has more attributes.

    It will be red in HTML output.
    :::
    ```

    A fenced Div will be converted to `<div>` with attributes in HTML output,
    e.g.,

    ``` html
    <div class="foo" id="bar" style="color: red;">
    </div>
    ```

    For LaTeX output, it can be converted to a LaTeX environment if both the
    class name and an attribute `data-latex` are present. For example,

    ``` markdown
    ::: {.tiny data-latex=""}
    This is _tiny_ text.
    :::
    ```

    will be converted to:

    ``` latex
    \begin{tiny}
    This is \emph{tiny} text.
    \end{tiny}
    ```

    The `data-latex` attribute can be used to specify arguments to the
    environment (which can be an empty string if the environment doesn't need an
    argument). For example,

    ``` markdown
    ::: {.minipage data-latex="{.5\linewidth}"}
    ```

    will be converted to:

    ``` latex
    \begin{minipage}{.5\linewidth}
    ```

    If a fenced Div doesn't have the `data-latex` attribute, the fence will be
    ignored, and its content will be written out normally without a surrounding
    environment. If a fenced Div has multiple class names (e.g., `{.a .b .c}`),
    only the first class name will be used as the LaTeX environment name.
    However, all class names will be used if the output format is HTML (e.g.,
    `<div class="a b c">`).

-   "Smart" HTML entities via ASCII characters, e.g., fractions can be written
    in the form `n/m`. Below are some example entities:

    ```{r, smartypants, echo=FALSE, eval=isTRUE(l10n_info()[['UTF-8']])}
    p = markdown:::pants[-(4:14)]
    knitr::kable(t(as.matrix(p)), col.names = sprintf('`%s`', names(p)))
    ```

[^1]: If you know C, I'll truly appreciate it if you could help with the LaTeX
    implementation in GFM: <https://github.com/github/cmark-gfm/issues/314>

[^2]: The specific number doesn't matter, as long as it's a unique footnote
    number in the document. For example, the first footnote can be `[^100]` and
    the second can be `[^64]`. Eventually they will appear as `[1]` and `[2]`.
    If you use the RStudio visual editor to edit Markdown documents, the
    footnote numbers will be automatically generated and updated when new
    footnotes are inserted before existing footnotes.

As mentioned earlier, a lot of features in Pandoc's Markdown are not supported
in the **markdown** package, such as citations and figure/table captions. In
addition, a lot of R Markdown features are not supported, either (e.g., tabbed
sections, code folding, and HTML widgets). Some HTML features may be implemented
via JavaScript, but currently it is not straightforward and may be improved in
future.

## Markdown Rendering

The main function to convert Markdown to other formats is `markdown::mark()`;
`mark_html()` and `mark_latex()` are simple wrapper functions for HTML and LaTeX
output, respectively. The function `mark()` generates a document fragment by
default, and the wrapper functions `mark_*()` generates full documents.

You can either call `markdown::mark()` to render a Markdown document
programmatically, or click the `Knit` button in RStudio to render a (Markdown or
R Markdown) document interactively. The latter requires you to specify the
output format in the `output` field in YAML metadata (see the section "YAML
metadata" below).

### Markdown options

The `options` argument of `mark()` can be used to enable/disable/set options to
control Markdown rendering. This argument can take either a list (e.g.,
`list(toc = TRUE, smart = FALSE)`) or a character vector (e.g.,
`c("+toc", "-smart")`, or equivalently, `+toc-smart`, where `+` means to enable
an option, and `-` means to disable an option). You can find available options
in `markdown::markdown_options()`, and their documentation on the help page of
this function, i.e., `?markdown::markdown_options`.

Most options take logical values (`TRUE` or `FALSE`), but a few of them take
other types of values. For example, the `highlight_code` option can be used to
set options for syntax highlighting code using the JavaScript library
`highlight.js`. This option can take a list of three possible elements,
`list(version, theme, languages)`, which specify:

-   The [JS library
    version](https://github.com/highlightjs/highlight.js/releases) (e.g.,
    `11.6.0`);

-   The theme (e.g., `github`), and you can find demos of themes at
    <https://highlightjs.org/static/demo/> and their names at
    <https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/>;

-   Additional languages to be supported. By default, `highlight.js` can syntax
    highlight more than 30 common languages (including R). If any code block is
    not syntax highlighted as expected, you may look up the JS filename for the
    language at
    <https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/>
    (e.g., `latex`).

### Templates

By default, `mark()` generates a document fragment (i.e., the body). To generate
a full document, you need a template. Below is a simple HTML template example:

``` html
<html>
  <head>
    <title>$title$</title>
  </head>

  <body>
  $body$
  </body>
</html>
```

It contains two variables, `$title$` and `$body$`. All variables will be
substituted by metadata values, except for `$body$`, which takes the value from
`mark()`.

The **markdown** has provided default templates for
[HTML](https://github.com/rstudio/markdown/blob/master/inst/resources/markdown.html)
and
[LaTeX](https://github.com/rstudio/markdown/blob/master/inst/resources/markdown.latex)
output. To use them, call `mark(..., template = TRUE)`, or the wrapper functions
`mark_html()` / `mark_latex()`. To pass metadata to templates, use the `meta`
argument, e.g.,

``` r
markdown::mark(..., meta = list(title = "My Title"), template = TRUE)
```

You can provide your own template file to the `template` argument, too.

### YAML metadata

Alternatively, the `meta` argument can read YAML metadata in the Markdown
document. The following variables can be set in the top-level fields in YAML:

-   `author`: The document author(s).

-   `date`: The date.

-   `title`: The document title.

For example:

``` yaml
---
title: "My Title"
author: "[Frida Gomam](https://example.com)"
date: "2023-01-09"
---
```

Note that you can use Markdown syntax in them.

Other variables need to be specified under
`output -> markdown::*_format -> meta`, where `*` can be `html` or `latex`,
e.g.,

``` yaml
---
title: "My Title"
output:
  markdown::html_format:
    meta:
      css: "style.css"
      js: "script.js"
  markdown::latex_format:
    meta:
      documentclass: "book"
      header_includes: "\\usepackage{microtype}"
---
```

The following metadata variables are supported for both HTML and LaTeX
templates:

-   `header-includes`, `include-before`, `include-after`: Either a vector of
    (HTML/LaTeX) code or a code file to be included in the header, before the
    body, or after the body of the output.

Variables specific to the HTML template:

-   `css`: A vector of CSS code or files to be included in the output. The
    default value is `markdown:::pkg_file('resources', 'default.css')`.

    If you want to use built-in CSS files in this package, you can only specify
    the base name, e.g., `default` means `default.css` in this package.

    You can also use web resources, e.g., `https://example.org/style.css`. One
    special case is [jsdelivr.com](https://www.jsdelivr.com) resources: if a
    `css` value starts with `@`, it will be recognized as a jsdelivr.com
    resource. The shorthand syntax is as follows (if you are not familiar with
    jsdelivr, you may read its documentation to understand the following example
    URLs):

    -   `@foo` will be converted to
        `https://cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/foo`, e.g.,
        `@default` means
        `https://cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/default.css`.

    -   `@path/to/file` (i.e., a value that contains slashes) will be converted
        to `https://cdn.jsdelivr.net/path/to/file`, e.g.,
        `@npm/@xiee/utils/js/center-img.js` will be converted to
        `https://cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js`.

    -   `@path/to/file1,file2` (comma-separated values and later values do not
        contain slashes) will be converted to
        `https://cdn.jsdelivr.net/combine/path/to/file1,path/to/file2` (this can
        be useful to
        [combine](https://www.jsdelivr.com/documentation#id-combine-multiple-files)
        multiple resources and load all at once).

    -   `@path1/to/file1,path2/to/file2` (comma-separated values and later
        values contain slashes) will be converted to
        `https://cdn.jsdelivr.net/combine/path1/to/file1,path2/to/file2`.

    This provides a way to reduce the output HTML file size by loading CSS from
    the web instead of embedding inside HTML, at the cost of requiring Internet
    connection when viewing the HTML file.

-   `highlight`: JavaScript code for syntax-highlighting code blocks. By
    default, the highlight.js library is used.

-   `js`: A vector of JavaScript code or JavaScript files to be included in the
    output. The syntax is the same as the `css` variable, e.g., `snap` means
    `snap.js` in this package, and `@snap` means a "jsdelivr" resource.

-   `math`: JavaScript code for rendering LaTeX math. By default, MathJax is
    used.

Variables specific to the LaTeX template:

-   `classoption`: A string containing options for the document class.

-   `documentclass`: The document class (by default, `article`).

Note that you can use either underscores or hyphens in the variable names.
Underscores will be normalized to hyphens internally, e.g., `header_includes`
will be converted to `header-includes`. This means if you use a custom template,
you must use hyphens instead of underscores as separators in variable names in
the template.

The above are variables supported in the default templates. If you use a custom
template, you can use arbitrary variable names, except for `$body$` (which is a
reserved name), and your metadata values will be passed to these variables in
your template.

Besides metadata variables, the aforementioned Markdown options can also be set
in YAML under `output -> markdown::*_format -> options`, e.g.,

``` yaml
output:
  markdown::html_format:
    options:
      toc: true
      highlight_code:
        theme: xcode
        languages: [diff, latex]
```

See the help page `?markdown::html_format` for possible fields in addiction to
`meta` and `options` that can be specified under the format name, e.g.,

``` yaml
output:
  markdown::latex_format:
    latex_engine: xelatex
    keep_md: true
    template: custom-template.tex
```

## Applications

The **markdown** package aims at lightweight with a minimal number of features.
You can build lightweight applications on top of it. In this section, we
introduce some example applications.

### HTML slides

With an extra CSS file and a JS file, you can create lightweight HTML slides:

``` yaml
---
output:
  markdown::html_format:
    meta:
      css: [default, slides]
      js: [slides]
---
```

You can learn more in [`vignette('slides', package = 'markdown')`](slides.html).

### HTML article

TODO.
